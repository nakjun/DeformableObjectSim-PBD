struct Tri
{
    float3 vertex0;
    float3 vertex1;
    float3 vertex2;
};

struct Line {
    float3 p0;
    float3 p1;
    float3 direction;
    float3 origin;
};

struct Triangle
{
    int v0;
    int v1;
    int v2;
};

struct collisionResult{
    bool isCollide;
    float3 hitPoint;
};

#define Epsilon 0.00001

uint triCount;
uint nodeCount;
uint totalNodeCount;
float convergence_factor;

float3 hitPoint;

RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> ProjectedPositions;
RWStructuredBuffer<float3> velocities;
RWStructuredBuffer<int3> directions;
RWStructuredBuffer<int> directionCount;
RWStructuredBuffer<Triangle> triangles;

void AtomicAddDirections(int index, float direction, int axis) {
    uint i_val = asuint(direction);
    uint tmp0 = 0;
    uint tmp1;

    [allow_uav_condition]
    while (true) {
        InterlockedCompareExchange(directions[index][axis], tmp0, i_val, tmp1);

        if (tmp1 == tmp0) {
            break;
        }

        tmp0 = tmp1;
        i_val = asuint(direction + asfloat(tmp1));
    }

    return;
}

///////////// Tri-Intersection function ////////////
float3 ProjectPointOnPlane(float3 p, float3 planeNormal, float3 planePoint)
{
    float d = dot(planeNormal, (p - planePoint)) / length(planeNormal) ;
    return p - d * planeNormal;
}

bool IsPointInsideTriangle(float3 p, Tri tri)
{
    float3 normal = normalize(cross(tri.vertex1 - tri.vertex0, tri.vertex2 - tri.vertex0));

    // ���� �ﰢ�� ��鿡 ����
    float3 projectedPoint = ProjectPointOnPlane(p, normal, tri.vertex0);

    //if (distance(projectedPoint, p) > 0.1) return false;
    if (distance(projectedPoint, p) > 0.01) return false;

    // ������ ���� ���� ���� �Ǵ� ����
    float3 edge1 = tri.vertex1 - tri.vertex0;
    float3 vp1 = projectedPoint - tri.vertex0;
    if (dot(cross(edge1, vp1), normal) < 0) return false;

    float3 edge2 = tri.vertex2 - tri.vertex1;
    float3 vp2 = projectedPoint - tri.vertex1;
    if (dot(cross(edge2, vp2), normal) < 0) return false;

    float3 edge3 = tri.vertex0 - tri.vertex2;
    float3 vp3 = projectedPoint - tri.vertex2;
    if (dot(cross(edge3, vp3), normal) < 0) return false;

    return true; // ��� �˻縦 ����ߴٸ�, ������ ���� �ﰢ�� ���ο� �ֽ��ϴ�.
}

collisionResult Intersect(Tri tri, Line ray)
{
    collisionResult cr;
    cr.isCollide = false;
    cr.hitPoint = float3(0.0, 0.0, 0.0);

    // Vectors from p1 to p2/p3 (edges)
    //Find vectors for edges sharing vertex/point p1
    float3 e1 = tri.vertex1 - tri.vertex0;
    float3 e2 = tri.vertex2 - tri.vertex0;

    ray.direction = normalize(ray.p1 - ray.p0);
    float3 p = cross(ray.direction, e2);

    //Calculate determinat
    float det = dot(e1, p);

    //if determinant is near zero, ray lies in plane of triangle otherwise not
    //if (det > -Mathf.Epsilon && det < Mathf.Epsilon)
    if (det > -Epsilon && det < Epsilon)
    {
        bool coplanar = IsPointInsideTriangle(ray.p0, tri);
        bool coplanar2 = IsPointInsideTriangle(ray.p1, tri);

        cr.hitPoint = float3(0.0, 0.0, 0.0);
        if (coplanar) cr.hitPoint = ray.p0;
        if (coplanar2) cr.hitPoint = ray.p1;

        cr.isCollide = coplanar || coplanar2;

        return cr;
    }
    float invDet = 1.0f / det;

    //calculate distance from p1 to ray origin
    ray.origin = ray.p0;
    float3 t = ray.origin - tri.vertex0;

    //Calculate u parameter
    float u = dot(t, p) * invDet;

    //Check for ray hit
    if (u < 0 || u > 1) { cr.isCollide = false;
    cr.hitPoint = float3(0.0, 0.0, 0.0);
    return cr; }

    //Prepare to test v parameter
    float3 q = cross(t, e1);

    //Calculate v parameter
    float v = dot(ray.direction, q) * invDet;

    //Check for ray hit
    if (v < 0 || u + v > 1) { cr.isCollide = false;
    cr.hitPoint = float3(0.0, 0.0, 0.0);
    return cr; }

    // intersection point
    cr.hitPoint = tri.vertex0 + u * e1 + v * e2;

    if ((dot(e2, q) * invDet) > Epsilon)
    {
        cr.isCollide = true;
        //ray does intersect            
        return cr;
    }

    // No hit at all
    cr.isCollide = false;
    cr.hitPoint = float3(0.0, 0.0, 0.0);
    return cr;
}

collisionResult CheckEdgeCollision(float3 vertex1, float3 vertex2, Tri t)
{
    //var edge = new Line();
    // Instantiate a Line struct
    Line edge;

    edge.p0 = vertex1;
    edge.p1 = vertex2;

    return Intersect(t, edge);
}

// bool Detection(Tri t1, Tri t2)
// {
//     bool c1 = 
//     CheckEdgeCollision(t1.vertex0, t1.vertex1, t2) || 
//     CheckEdgeCollision(t1.vertex0, t1.vertex2, t2) || 
//     CheckEdgeCollision(t1.vertex1, t1.vertex2, t2);

//     bool c2 = 
//     CheckEdgeCollision(t2.vertex0, t2.vertex1, t1) || 
//     CheckEdgeCollision(t2.vertex0, t2.vertex2, t1) || 
//     CheckEdgeCollision(t2.vertex1, t2.vertex2, t1);

//     return c1 && c2;
// }

int3 calculateSpace(float3 position) {
    return int3((position.x + 50.0) / 0.5, (position.y + 50.0) / 0.5, (position.z + 50.0) / 0.5);
}

bool compareVec3(int3 a, int3 b) {
    return all(a == b);
}

bool areTriangleSameVoxel(Tri t1, Tri t2) {
    int3 cloth_space1 = calculateSpace(t1.vertex0);
    int3 cloth_space2 = calculateSpace(t1.vertex1);
    int3 cloth_space3 = calculateSpace(t1.vertex2);

    int3 object_space1 = calculateSpace(t2.vertex0);
    int3 object_space2 = calculateSpace(t2.vertex1);
    int3 object_space3 = calculateSpace(t2.vertex2);

    if(compareVec3(cloth_space1, object_space1) || compareVec3(cloth_space1, object_space2) || compareVec3(cloth_space1, object_space3)) {
        return true;
    }
    if(compareVec3(cloth_space2, object_space1) || compareVec3(cloth_space2, object_space2) || compareVec3(cloth_space2, object_space3)) {
        return true;
    }
    if(compareVec3(cloth_space3, object_space1) || compareVec3(cloth_space3, object_space2) || compareVec3(cloth_space3, object_space3)) {
        return true;
    }
    return false;
}


float3 caclulateNormal(float3 v0, float3 v1, float3 v2){
    // 삼각형의 두 변을 나타내는 벡터 계산
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;

    // 두 벡터의 외적을 계산하여 삼각형의 면에 수직인 벡터(면의 normal)을 구함
    float3 normal = cross(edge1, edge2);

    // normal 벡터를 정규화하여 단위 벡터로 만듦
    normal = normalize(normal);

    return normal;
}

float3 Reflect(float3 V, float3 N)
{
    return V - 2 * dot(V, N) * N;
}

#pragma kernel CollisionNodeTriangle
[numthreads(32, 32, 1)]
void CollisionNodeTriangle (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    uint j = id.y;


    int objIndex1 = floor(float(i) / nodeCount);
    int objIndex2 = floor(float(j) / triCount);

    if(objIndex1 != objIndex2 && objIndex1 < objIndex2)
    {   
        //triangle information     
        Triangle t2 = triangles[j];
        
        Tri t2Vertices;
        t2Vertices.vertex0 = positions[t2.v0];
        t2Vertices.vertex1 = positions[t2.v1];
        t2Vertices.vertex2 = positions[t2.v2];

        float3 norm = caclulateNormal(t2Vertices.vertex0, t2Vertices.vertex1, t2Vertices.vertex2);

        //edge information
        float3 v1 = positions[i];
        float3 vel = velocities[i];

        float3 v2 = v1 + (vel * 0.001);
        
        collisionResult result = CheckEdgeCollision(v1, v2, t2Vertices);
        if(result.isCollide){
            
            float3 diff = (result.hitPoint - v1);

            InterlockedAdd(directions[i][0], diff.x * 100);
            InterlockedAdd(directions[i][1], diff.y * 100);
            InterlockedAdd(directions[i][2], diff.z * 100);

            // InterlockedAdd(directionCount[i],1);
            
            // directions[i][0] = int(result.hitPoint.x * 100);
            // directions[i][1] = int(result.hitPoint.y * 100);
            // directions[i][2] = int(result.hitPoint.z * 100);
        }
    }
}

// #pragma kernel CollisionResponse
// [numthreads(1024, 1, 1)]
// void CollisionResponse (uint3 id : SV_DispatchThreadID)
// {
//     uint i = id.x;
//     float3 pos = positions[i];
//     float3 vel = velocities[i];

//     if(directionCount[i] > 0)
//     {
//         float3 nPos = (float3(directions[i][0], directions[i][1], directions[i][2]) / 100.0) / directionCount[i];
//         pos = nPos;
        
//         vel *= -0.01;
//     }
//     velocities[i] = vel;
//     positions[i] = pos;
    
//     directions[i][0] = int(0);
//     directions[i][1] = int(0);
//     directions[i][2] = int(0);
//     directionCount[i] = int(0);
// }

#pragma kernel CollisionResponse
[numthreads(1024, 1, 1)]
void CollisionResponse (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    float3 dr = float3(0.0, 0.0, 0.0);
    if(directionCount[i] > 0)
    {
        dr = float3(directions[i][0]/100.0,directions[i][1]/100.0,directions[i][2]/100.0);
        dr = dr / directionCount[i];
    }
    ProjectedPositions[i] += dr * convergence_factor;
    
    directions[i][0] = int(0);
    directions[i][1] = int(0);
    directions[i][2] = int(0);
    directionCount[i] = int(0);
}

#pragma kernel CollisionHandling
[numthreads(32,32,1)]
void CollisionHandling (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    uint j = id.y;

    int objIndex1 = floor(float(i) / triCount);
    int objIndex2 = floor(float(j) / triCount);

    if(objIndex1 != objIndex2 && objIndex1 <= objIndex2)
    {
        Triangle t1 = triangles[i];
        Triangle t2 = triangles[j];

        Tri t1Vertices;
        t1Vertices.vertex0 = ProjectedPositions[t1.v0];
        t1Vertices.vertex1 = ProjectedPositions[t1.v1];
        t1Vertices.vertex2 = ProjectedPositions[t1.v2];

        Tri t2Vertices;
        t2Vertices.vertex0 = ProjectedPositions[t2.v0];
        t2Vertices.vertex1 = ProjectedPositions[t2.v1];
        t2Vertices.vertex2 = ProjectedPositions[t2.v2];

        bool voxelComparision = areTriangleSameVoxel(t1Vertices, t2Vertices);

        if(!voxelComparision) return;

        // collisionResult r1 = CheckEdgeCollision(t1Vertices.vertex0, t1Vertices.vertex1, t2Vertices);
        // collisionResult r2 = CheckEdgeCollision(t1Vertices.vertex0, t1Vertices.vertex2, t2Vertices);
        // collisionResult r3 = CheckEdgeCollision(t1Vertices.vertex1, t1Vertices.vertex2, t2Vertices);

        // collisionResult r4 = CheckEdgeCollision(t2Vertices.vertex0, t2Vertices.vertex1, t1Vertices);
        // collisionResult r5 = CheckEdgeCollision(t2Vertices.vertex0, t2Vertices.vertex2, t1Vertices);
        // collisionResult r6 = CheckEdgeCollision(t2Vertices.vertex1, t2Vertices.vertex2, t1Vertices);


        collisionResult results[6];
        results[0] = CheckEdgeCollision(t1Vertices.vertex0, t1Vertices.vertex1, t2Vertices);
        results[1] = CheckEdgeCollision(t1Vertices.vertex0, t1Vertices.vertex2, t2Vertices);
        results[2] = CheckEdgeCollision(t1Vertices.vertex1, t1Vertices.vertex2, t2Vertices);
        results[3] = CheckEdgeCollision(t2Vertices.vertex0, t2Vertices.vertex1, t1Vertices);
        results[4] = CheckEdgeCollision(t2Vertices.vertex0, t2Vertices.vertex2, t1Vertices);
        results[5] = CheckEdgeCollision(t2Vertices.vertex1, t2Vertices.vertex2, t1Vertices);

        bool c1 = (results[0].isCollide || results[1].isCollide || results[2].isCollide);
        bool c2 = (results[3].isCollide || results[4].isCollide || results[5].isCollide);        

        //InterlockedAdd(directions[t1.v0][0], -1);
        if(c1&&c2)
        {
            float3 collisionCenter = float3(0.0, 0.0, 0.0);
            int n = 0;
            for (int k = 0; k < 6; k++)
            {
                if (results[k].isCollide)
                {
                    collisionCenter += results[k].hitPoint;
                    n += 1;
                }
            }
            collisionCenter /= float(n);
            float3 centerT1 = (t1Vertices.vertex0+t1Vertices.vertex1+t1Vertices.vertex2) / 3.0;
            float3 centerT2 = (t2Vertices.vertex0+t2Vertices.vertex1+t2Vertices.vertex2) / 3.0;

            float3 normT1 = caclulateNormal(t1Vertices.vertex0, t1Vertices.vertex1, t1Vertices.vertex2);
            float3 normT2 = caclulateNormal(t2Vertices.vertex0, t2Vertices.vertex1, t2Vertices.vertex2);

            // float3 dirT1 = normalize(collisionCenter - centerT1);
            // float3 dirT2 = normalize(collisionCenter - centerT2);

            float kCollisionConstraintStiffnessIterInd = 0.8;


            //point1
            if(results[0].isCollide && results[1].isCollide)
            {
                float s = dot(positions[t1.v0] - collisionCenter, normT2);                
                float3 dir = -s * kCollisionConstraintStiffnessIterInd *  normT2;

                InterlockedAdd(directions[t1.v0][0], dir.x * 100);
                InterlockedAdd(directions[t1.v0][1], dir.y * 100);
                InterlockedAdd(directions[t1.v0][2], dir.z * 100);
                InterlockedAdd(directionCount[t1.v0],1);
            }
            //point2
            if(results[0].isCollide && results[2].isCollide)
            {
                float s = dot(positions[t1.v1] - collisionCenter, normT2);                
                float3 dir = -s * kCollisionConstraintStiffnessIterInd *  normT2;

                InterlockedAdd(directions[t1.v1][0], dir.x * 100);
                InterlockedAdd(directions[t1.v1][1], dir.y * 100);
                InterlockedAdd(directions[t1.v1][2], dir.z * 100);
                InterlockedAdd(directionCount[t1.v1],1);
            }
            if(results[1].isCollide && results[2].isCollide)
            {   
                float s = dot(positions[t1.v2] - collisionCenter, normT2);                
                float3 dir = -s * kCollisionConstraintStiffnessIterInd *  normT2;
                InterlockedAdd(directions[t1.v2][0], dir.x * 100);
                InterlockedAdd(directions[t1.v2][1], dir.y * 100);
                InterlockedAdd(directions[t1.v2][2], dir.z * 100);
                InterlockedAdd(directionCount[t1.v2],1);
            }

            //T2

            //point1
            if(results[3].isCollide && results[4].isCollide)
            {
                float s = dot(positions[t2.v0] - collisionCenter, normT1);                
                float3 dir = -s * kCollisionConstraintStiffnessIterInd *  normT1;
                InterlockedAdd(directions[t2.v0][0], dir.x * 100);
                InterlockedAdd(directions[t2.v0][1], dir.y * 100);
                InterlockedAdd(directions[t2.v0][2], dir.z * 100);
                InterlockedAdd(directionCount[t2.v0],1);
            }
            //point2
            if(results[3].isCollide && results[5].isCollide)
            {
                float s = dot(positions[t2.v1] - collisionCenter, normT1);                
                float3 dir = -s * kCollisionConstraintStiffnessIterInd *  normT1;
                InterlockedAdd(directions[t2.v1][0], dir.x * 100);
                InterlockedAdd(directions[t2.v1][1], dir.y * 100);
                InterlockedAdd(directions[t2.v1][2], dir.z * 100);
                InterlockedAdd(directionCount[t2.v1],1);
            }
            if(results[4].isCollide && results[5].isCollide)
            {
                float s = dot(positions[t2.v2] - collisionCenter, normT1);                
                float3 dir = -s * kCollisionConstraintStiffnessIterInd *  normT1;
                InterlockedAdd(directions[t2.v2][0], dir.x * 100);
                InterlockedAdd(directions[t2.v2][1], dir.y * 100);
                InterlockedAdd(directions[t2.v2][2], dir.z * 100);
                InterlockedAdd(directionCount[t2.v2],1);
            }

            // if(results[0].isCollide && results[1].isCollide)
            // {
            //     AtomicAddDirections(t1.v0, dirT1.x, 0);
            //     AtomicAddDirections(t1.v0, dirT1.y, 1);
            //     AtomicAddDirections(t1.v0, dirT1.z, 2);                
            //     InterlockedAdd(directionCount[t1.v0],1);
            // }
            // //point2
            // if(results[0].isCollide && results[2].isCollide)
            // {
            //     AtomicAddDirections(t1.v1, dirT1.x, 0);
            //     AtomicAddDirections(t1.v1, dirT1.y, 1);
            //     AtomicAddDirections(t1.v1, dirT1.z, 2); 
            //     InterlockedAdd(directionCount[t1.v1],1);
            // }
            // if(results[1].isCollide && results[2].isCollide)
            // {
            //     AtomicAddDirections(t1.v2, dirT1.x, 0);
            //     AtomicAddDirections(t1.v2, dirT1.y, 1);
            //     AtomicAddDirections(t1.v2, dirT1.z, 2); 
            //     InterlockedAdd(directionCount[t1.v2],1);
            // }

            // //T2

            // //point1
            // if(results[3].isCollide && results[4].isCollide)
            // {
            //     AtomicAddDirections(t2.v0, dirT2.x, 0);
            //     AtomicAddDirections(t2.v0, dirT2.y, 1);
            //     AtomicAddDirections(t2.v0, dirT2.z, 2); 
            //     InterlockedAdd(directionCount[t2.v0],1);
            // }
            // //point2
            // if(results[3].isCollide && results[5].isCollide)
            // {
            //     AtomicAddDirections(t2.v1, dirT2.x, 0);
            //     AtomicAddDirections(t2.v1, dirT2.y, 1);
            //     AtomicAddDirections(t2.v1, dirT2.z, 2); 
            //     InterlockedAdd(directionCount[t2.v1],1);
            // }
            // if(results[4].isCollide && results[5].isCollide)
            // {
            //     AtomicAddDirections(t2.v2, dirT2.x, 0);
            //     AtomicAddDirections(t2.v2, dirT2.y, 1);
            //     AtomicAddDirections(t2.v2, dirT2.z, 2); 
            //     InterlockedAdd(directionCount[t2.v2],1);
            // }

        }
    }
}